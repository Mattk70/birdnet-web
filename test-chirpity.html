<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>BirdNet web inference test</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-wasm/dist/tf-backend-wasm.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgpu/dist/tf-backend-webgpu.js"></script>
    <style>
      html, body {
          font-size: 15px;
          font-family: 'Courier New', Courier, monospace;
          background-color: #222;
          padding: 10px;
          margin: 0;
          color: bisque;
      }
      .error {
        color: rgb(224, 99, 99);
      }
  </style>
  </head>
  <body>
    <button onClick="run()">Test</button>
    <div id="log"></div>
    <script>
      function bitReverse(num, bits) {
          let reversed = 0;
          for (let i = 0; i < bits; i++) {
              if ((num & (1 << i))) {
                  reversed |= (1 << (bits - 1 - i));
              }
          }
          return reversed;
      }
      tf.registerKernel({
    kernelName: 'FFT2',
    backendName: 'webgl',
    kernelFunc: ({ backend, inputs: { input } }) => {
        const innderDim = input.shape[input.shape.length - 1]
        const batch = tf.util.sizeFromShape(input.shape) / innderDim
        const reorderMap = new Array(innderDim).fill(0).map((_, i) => bitReverse(i, Math.log2(innderDim)))
        let currentTensor = backend.runWebGLProgram({
            variableNames: ['mapvalue'],
            outputShape: [batch, innderDim * 2],
            userCode: `
int reorderMap[${innderDim}] = int[](${reorderMap.join(', ')});
void main() {
  ivec2 coords = getOutputCoords();
  int batch = coords[0];
  int k = reorderMap[coords[1] % ${innderDim}];
  float result = coords[1] < ${innderDim} ? getMapvalue(batch, k) : 0.0;
  setOutput(result);
}`
        }, [input], 'float32')
        for (let len = 1; len < innderDim; len *= 2) {
            let prevTensor = currentTensor
            currentTensor = backend.runWebGLProgram({
                variableNames: [`value_${len}`],
                outputShape: [batch, len*2 >= innderDim ? innderDim : innderDim * 2],
                userCode: `void main() {
ivec2 coords = getOutputCoords();
int batch = coords[0];
int i = coords[1];
int k = i % ${innderDim};
int isHigh = (k % ${len * 2}) / ${len};
int isImag = i / ${innderDim};
int isReal = 1 - isImag;
int highSign = (1 - isHigh * 2);
int baseIndex = k - isHigh * ${len};
float t = ${Math.PI / len} * float(k % ${len});
float a = cos(t);
float b = sin(-t);
float evenK_re = getValue_${len}(batch, baseIndex);
float oddK_re = getValue_${len}(batch, baseIndex + ${len});
float evenK_im = getValue_${len}(batch, baseIndex + ${innderDim});
float oddK_im = getValue_${len}(batch, baseIndex + ${len + innderDim});
float outp = (evenK_im + (oddK_re * b + oddK_im * a) * float(highSign)) * float(isImag)
+ (evenK_re + (oddK_re * a - oddK_im * b) * float(highSign)) * float(isReal);
setOutput(outp);
}` }, [currentTensor], 'float32')
            backend.disposeIntermediateTensorInfo(prevTensor)
        }
        return currentTensor
    }
})
      function arrayProduct (arr) {
        let product = 1;
        for (let i = 0; i < arr.length; i++) { product *= arr[i] }
        return product;
      }
      function flatDispatchLayout(shape) { return {x: shape.map((d, i) => i)} }
      function computeDispatch(layout, outputShape, workgroupSize = [1, 1, 1], elementsPerThread = [1, 1, 1]) {
        return [Math.ceil(arrayProduct(layout.x.map(d => outputShape[d])) /(workgroupSize[0] * elementsPerThread[0])),
          layout.y ? Math.ceil(arrayProduct(layout.y.map(d => outputShape[d])) / (workgroupSize[1] * elementsPerThread[1])) : 1,
          layout.z ? Math.ceil(arrayProduct(layout.z.map(d => outputShape[d])) / (workgroupSize[2] * elementsPerThread[2])) : 1]
      }
    tf.registerKernel({
    kernelName: 'FFT2',
    backendName: 'webgpu',
    kernelFunc: ({ backend, inputs: { input } }) => {
        const innderDim = input.shape[input.shape.length - 1]
        const batch = tf.util.sizeFromShape(input.shape) / innderDim
        const workgroupSize = [64, 1, 1]
        const reorderMap = new Array(innderDim).fill(0).map((_, i) => bitReverse(i, Math.log2(innderDim)))
        const dispatchLayout = flatDispatchLayout([batch, innderDim * 2])
        const dispatch = computeDispatch(dispatchLayout, [batch, innderDim * 2], workgroupSize)
        let currentTensor = backend.runWebGPUProgram({
            variableNames: ['X'],
            outputShape: [batch, innderDim * 2],
            workgroupSize,
            shaderKey: `fft_permut_${innderDim}`,
            dispatchLayout,
            dispatch,
            getUserCode: () => `
              const reorderMap = array(${reorderMap.join(', ')});
              fn main(index: i32) {
                let coords = getOutputCoords();
                let batch = coords[0];
                let k = reorderMap[coords[1]];
                if (coords[1] < ${innderDim}) {
                    let k = reorderMap[coords[1]];
                    let real = getX(batch, k);
                    setOutputAtIndex(index, real);
                } else {
                    setOutputAtIndex(index, 0);
                }
              }`
        }, [input], 'float32')
        for (let len = 1; len < innderDim; len *= 2) {
            let prevTensor = currentTensor
            const uniformDataStep = [
              {type: 'int32', data: [innderDim]},
              {type: 'int32', data: [len]}
            ];
            let isLastStep = len*2 >= innderDim
            currentTensor = backend.runWebGPUProgram({
                variableNames: [`value`],
                outputShape: [batch, isLastStep ? innderDim : innderDim * 2],
                workgroupSize,
                uniforms: 'innerDim : i32, len: i32,',
                shaderKey: `fft_step`,
                dispatchLayout: flatDispatchLayout([batch, innderDim * 2]),
                dispatch: computeDispatch(flatDispatchLayout([batch, innderDim * 2]), [batch, innderDim * 2], workgroupSize),
                getUserCode: () => `fn main(index: i32) {
                    let coords = getOutputCoords();
                    let batch = coords[0];
                    let i = coords[1];
                    let innerDim = uniforms.innerDim;
                    let k = i % innerDim;
                    let isHigh = (k % (uniforms.len * 2)) / uniforms.len;
                    let isImag = i / innerDim;
                    let isReal = 1 - isImag;
                    let highSign = (1 - isHigh * 2);
                    let baseIndex = k - isHigh * uniforms.len;
                    let t = ${Math.PI} / f32(uniforms.len) * f32(k % uniforms.len);
                    let a = cos(t);
                    let b = sin(-t);
                    let evenK_re = getValue(batch, baseIndex);
                    let oddK_re = getValue(batch, baseIndex + uniforms.len);
                    let evenK_im = getValue(batch, baseIndex + innerDim);
                    let oddK_im = getValue(batch, baseIndex + uniforms.len + innerDim);
                    let real = (evenK_re + (oddK_re * a - oddK_im * b) * f32(highSign));
                    let imag = (evenK_im + (oddK_re * b + oddK_im * a) * f32(highSign));
                    setOutputAtIndex(index, real * f32(isReal) + imag * f32(isImag));
                    }`
                }, [currentTensor], 'float32', uniformDataStep)
            backend.disposeData(prevTensor.dataId)
        }
        return currentTensor
    }
})
      function stft(signal, frameLength, frameStep, fftLength, windowFn) {
        const framedSignal = tf.signal.frame(signal, frameLength, frameStep)
        const input = tf.mul(framedSignal, windowFn(frameLength))
        let innerDim = input.shape[input.shape.length - 1]
        const batch = input.size / innerDim
        const realValues = tf.engine().runKernel('FFT2', {input: tf.reshape(input, [batch, innerDim])})
        const half = Math.floor(innerDim / 2) + 1
        const realComplexConjugate = tf.split(
            realValues, [half, innerDim - half],
            realValues.shape.length - 1)
        const outputShape = input.shape.slice()
        outputShape[input.shape.length - 1] = half
        return tf.reshape(realComplexConjugate[0], outputShape)
      }
      class MelSpecLayerSimple extends tf.layers.Layer {
          constructor(config) {
              super(config)
              this.sampleRate = config.sampleRate
              this.specShape = config.specShape
              this.frameStep = config.frameStep
              this.frameLength = config.frameLength
              this.melFilterbank = tf.tensor2d(config.melFilterbank)
          }
          build(inputShape) {
              this.magScale = this.addWeight(
                  'magnitude_scaling',
                  [],
                  'float32',
                  tf.initializers.constant({ value: 1.23 })
              );
              super.build(inputShape)
          }
          computeOutputShape(inputShape) {
              return [inputShape[0], this.specShape[0], this.specShape[1], 1];
          }
          call(inputs) {
            return tf.tidy(() => {
                  inputs = inputs[0];
                  const inputList = tf.split(inputs, inputs.shape[0])
                  const specBatch = inputList.map(input =>{
                      input = input.squeeze();
                      input = tf.sub(input, tf.min(input, -1, true));
                      input = tf.div(input, tf.max(input, -1, true).add(0.000001));
                      input = tf.sub(input, 0.5);
                      input = tf.mul(input, 2.0);

                      let spec;
                      if (window.useFastFFT) {
                        spec = stft(
                          input,
                          this.frameLength,
                          this.frameStep,
                          this.frameLength,
                          tf.signal.hannWindow,
                        )
                      } else {
                        spec = tf.signal.stft(
                            input,
                            this.frameLength,
                            this.frameStep,
                            this.frameLength,
                            tf.signal.hannWindow,
                        )
                        spec = tf.cast(spec, 'float32')
                      }
                      spec = tf.matMul(spec, this.melFilterbank)
                      spec = spec.pow(2.0)
                      spec = spec.pow(tf.div(1.0, tf.add(1.0, tf.exp(this.magScale.read()))))
                      spec = tf.reverse(spec, -1)
                      spec = tf.transpose(spec)
                      spec = spec.expandDims(-1)
                      return spec;
                  })
                  return tf.stack(specBatch)
              });
          }
          static get className() { return 'MelSpecLayerSimple' }
      }
      tf.serialization.registerClass(MelSpecLayerSimple);

      window.wave = null
      window.tfModel = null
      window.birds = null
      window.useFastFFT = false
      async function runBirdNet() {
        await tf.ready()
        const params = new URL(location).searchParams
        const profile = params.get('profile') === 'on'
        window.useFastFFT = params.get('fast_fft') === 'on'
        await tf.setBackend(params.get('backend') || 'cpu')
        window.log.innerHTML = `tfjs backend: ${tf.getBackend()}, profile: ${profile ? 'on' : 'off'}, fast_fft: ${window.useFastFFT ? 'on' : 'off'}<br/>`
        if (!window.wave || !window.tfModel || !window.birds) {
          window.log.innerHTML += `Loading birds list... `
          let start = performance.now()
          window.birds = (await fetch('birds.txt').then(r => r.text())).split('\n')
          window.log.innerHTML += `${Math.round(performance.now() - start)}ms, ${birds.length} birds [OK]<br/>`

          window.log.innerHTML += `Loading test audio data... `
          start = performance.now()
          window.wave = tf.tensor([await fetch('wave.json').then(r => r.json())])
          window.log.innerHTML += `${Math.round(performance.now() - start)}ms [OK]<br/>`

          window.log.innerHTML += `Loading model... `
          start = performance.now()
          window.tfModel = await tf.loadLayersModel('models/birdnet-js-chirpity/model.json', {
              weightPathPrefix: 'models/birdnet-js-chirpity/',
          })
          window.log.innerHTML += `${Math.round(performance.now() - start)}ms [OK]<br/>`
          window.log.innerHTML += `Warm up... `
          await new Promise(resolve => setTimeout(resolve, 50)) // for UI to update before long sync operation
          start = performance.now()
          tf.engine().startScope()
          await tfModel.predict(tf.zeros(wave.shape)).data()
          tf.engine().endScope()
          window.log.innerHTML += `${Math.round(performance.now() - start)}ms [OK]<br/>`
        }
        window.log.innerHTML += `Inference... `
        await new Promise(resolve => setTimeout(resolve, 50)) // for UI to update before long sync operation
        start = performance.now()
        let prediction = null
        if (profile) {
          tf.engine().startScope()
          const profile_info = await tf.profile(async () => {
            prediction = await tfModel.predict(wave).data()
          })
          tf.engine().endScope()
          profile_info.kernels.sort((a, b) => b.kernelTimeMs - a.kernelTimeMs)
          let totalKernelsTime = 0
          profile_info.kernels.forEach(k => { totalKernelsTime += k.kernelTimeMs })
          console.log('profile_info:', profile_info)
          window.log.innerHTML += `${Math.round(performance.now() - start)}ms, kernel time: ${Math.round(totalKernelsTime)}ms [OK]<br/>`
          for (let kernel of profile_info.kernels.slice(0, 40)) {
            if (kernel.kernelTimeMs < 1) { break }
            window.log.innerHTML += `${kernel.name.padEnd(20, '.')} ${Math.round(kernel.kernelTimeMs)}ms<br/>`
          }
        } else {
          tf.engine().startScope()
          prediction = await tfModel.predict(wave).data()
          tf.engine().endScope()
          window.log.innerHTML += `${Math.round(performance.now() - start)}ms [OK]<br/>`
        }
        
        
        const THRESHOLD = 0.1
        const SIGMOID_SENSITIVITY = 1
        let guessList = []

        for (let i = 0; i < prediction.length; i++) {    
            const confidence = prediction[i] // 1 / (1 + Math.E ** (-SIGMOID_SENSITIVITY * Math.min(15, Math.max(-15, prediction[i]))))
            if (confidence > 0.1) {
                guessList.push({ bird: (birds[i] || '_').split('_')[1], confidence })
            }
        }
        guessList.sort((a, b) => a.confidence - b.confidence)
        window.log.innerHTML += '<br/>===== RESULT:<br/>'
        guessList.forEach(({ bird, confidence }) => {
            window.log.innerHTML += `${bird}, confidence: ${confidence.toFixed(2)}<br/>`
        })
      }
      function run() {
        runBirdNet().catch((e) => {
          window.log.innerHTML += `<p class="error">${e.stack}<p/>`
          throw e
        })
      }
    </script>
  </body>
</html>